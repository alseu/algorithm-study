# 다이나믹 프로그래밍

한 번 계산한 문제는 다시 계산하지 않는다

연산 속도와 메모리 공간을 최대한 활용할 수 있는 알고리즘이 최선

그러나, 메모리 공간을 조금 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법의 알고리즘이 있는데, 그 중 하나가 다이나믹 프로그래밍(동적 계획법)

## 피보나치

피보나치 수열의 점화식은 아래와 같다.

$a_{n+2} = f(a_{n+1}, a_n) = a_{n+1} + a_n$

결과적으로 아래와 같이 정의할 수 있다.

$a_n = a_{n-1} + a_{n-2}, a_1 = 1, a_2 = 1$

n번째 피보나치 수는 (n-1)번째 피보나치수 + (n-2)번째 피보나치수 (첫 번째, 두 번째 피보나치 수는 1)

이런 규칙적인 수열을 배열이나 리스트에 미리 저장해놓고(캐싱)

같은 정보가 필요할 때는 그대로 리스트에서 가져오기만 하면 된다.

```python
d = [0] * 100

def fibonacci(x) :
    if x == 1 or x == 2 :
        return 1
    if d[x] != 0 :
        return d[x]
    
    d[x] = fibonacci(x-1) + fibonacci(x-2)
    return d[x]

print(fibo(99))

# 결과
# 218922995834555169026
```