# 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙
# 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다.
# 단, 서로 다른 인덱스에 해당하는 수가 같을 경우에는 서로 다른 것으로 간주한다.
# 배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 큰 수의 법칙에 따른 결과를 출력
# (2 <= N <= 1000) , (1 <= M <= 10000) , (1 <= K <= 10000)
# 입력으로 주어지는 K는 항상 M보다 작거나 같다.

n, m, k = map(int, input().split(' '))

num = sorted(list(map(int, input().split(' '))), reverse=True)  # 내림차순 정렬

sum = 0
count = 0

for i in range (m) :
    if count >= k :
        sum     += num[1]   # 두 번째로 큰 수
        count    = 0
        continue

    sum     += num[0]   # 가장 큰 수
    count   += 1

print(sum)

''' 효율적으로 해결 '''
# 반복되는 수열
# 가장 큰 수와 두 번째로 큰 수가 반복되는 수열
# M을 K+1로 나눈 몫이 수열이 반복되는 횟수, 여기에 K를 곱하면 가장 큰 수가 등장하는 횟수가 됨
# M이 (K+1)로 나누어 떨어지지 않는 경우, M을 K+1로 나눈 나머지 만큼 가장 큰 수가 추가로 더해지므로, 그만큼을 추가로 더해주어야 한다.
# 즉, 가장 큰 수가 더해지는 횟수 M // (K+1) * K + M % (K+1)

count = (m // (k+1)) * k
count += m % (k+1)

sum = 0
sum += count * num[0]
sum += (m - count) * num[1]

print(sum)