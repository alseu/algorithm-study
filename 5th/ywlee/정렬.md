# 정렬

데이터를 특정한 기준에 따라서 순서대로 나열하는 것

선택, 삽입, 퀵, 계수 정렬

# 선택 정렬

가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복

매번 가장 작은 데이터를 `선택` 한다

N개의 데이터 중 가장 작은 데이터를 앞으로 보내는 과정을 N-1번 반복하면 정렬이 완료된다.

## Python 에서 Swap 방법
        
    # 0번과 1번을 Swap
    array = [3, 5]
    array[0], array[1] = array[1], array[0]

## 선택 정렬의 시간복잡도

    N + (N-1) + (N-2) + ... + 2
    = N * (N+1) / 2
    = (N^2 + N) / 2
    
    -> O(N^2)

# 삽입 정렬

데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입

`데이터가 거의 정렬되어 있을 때` 효과적이다.

소스로 작동 방식을 확인하는 편이 쉽다.

    array = [ 7 , 5 , 9 , 0 , 3 , 1 , 6 , 2 , 4 , 8 ]

    for i in range(1, len(array)) :
        for j in range(i, 0, -1) : 
            if array[j] < array[j-1] : # 한 칸씩 왼쪽으로 이동
                array[j], array[j-1] = array[j-1], array[j]
            else : # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
                break

## 삽입 정렬의 시간복잡도

    O(N^2)

    최선의 경우, O(N) [데이터가 거의 정렬되어 있는 경우]

# 퀵 정렬

'기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다'

교환하기 위한 `기준`을 `피벗(Pivot)`이라고 표현

- 호어 분할 : 리스트에서 첫 번째 데이터를 피벗으로 정한다.

    array = [ 7 , 5 , 9 , 0 , 3 , 1 , 6 , 2 , 4 , 8 ]

    def quick_sort(array, start, end) :
        if start >= end :   # 원소가 1개인 경우 종료
            return
        pivot = start # 피벗은 첫 번째 원소

        left  = start + 1
        right = end
        while left <= right :
            # 피벗보다 큰 데이터를 찾을 때까지 반복
            while left <= end and array[left] <= array[pivot] :
                left += 1
            # 피벗보다 작은 데이터를 찾을 떄까지 반복
            while right > start and array[right] >= array[pivot] :
                right -= 1
            if left > right : # 엇갈렸다면 작은 데이터와 피벗을 교체
                array[right], array[pivot] = array[pivot], array[right]
            else :            # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
                array[left], array[right] = array[right], array[left]
            
        # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
        quick_sort(array, start, right-1)
        quick_sort(array, right+1, end)
    
    quick_sort(array, 0, len(array)-1)

# 계수 정렬

